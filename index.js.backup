const fs = require('fs-extra');
const path = require('path');
const yaml = require('js-yaml');
const ParquetWriter = require('./parquet-writer');

module.exports = function(app) {
  let plugin = {};
  let unsubscribes = [];
  let dataBuffers = new Map(); // Store buffers by SignalK path
  let activeRegimens = new Set(); // Track active regimen states
  let subscribedPaths = new Set(); // Track currently subscribed SignalK paths
  let saveInterval;
  let consolidationInterval;
  let parquetWriter;

  plugin.id = 'zennora-signalk-parquet';
  plugin.name = 'Zennora SignalK to Parquet';
  plugin.description = 'Save SignalK marine data directly to Parquet files with regimen-based control';

  plugin.start = function(options) {
    app.debug('Starting Zennora SignalK to Parquet plugin');

    // Get vessel MMSI from SignalK
    const vesselMMSI = app.getSelfPath('mmsi') || app.getSelfPath('name') || 'unknown_vessel';
    
    // Use SignalK's application data directory
    const defaultOutputDir = path.join(app.getDataDirPath(), 'zennora-signalk-parquet');
    
    const config = {
      bufferSize: options?.bufferSize || 1000,
      saveIntervalSeconds: options?.saveIntervalSeconds || 30,
      outputDirectory: options?.outputDirectory || defaultOutputDir,
      filenamePrefix: options?.filenamePrefix || 'signalk_data',
      retentionDays: options?.retentionDays || 7,
      fileFormat: options?.fileFormat || 'parquet', // 'json', 'csv', or 'parquet'
      vesselMMSI: vesselMMSI,
      paths: options?.paths || getDefaultPaths()
    };

    // Initialize ParquetWriter
    parquetWriter = new ParquetWriter({ format: config.fileFormat });

    // Ensure output directory exists
    fs.ensureDirSync(config.outputDirectory);

    // Subscribe to command paths first (these control regimens)
    subscribeToCommandPaths(config);

    // Subscribe to data paths based on initial regimen states
    updateDataSubscriptions(config);

    // Set up periodic save
    saveInterval = setInterval(() => {
      saveAllBuffers(config);
    }, config.saveIntervalSeconds * 1000);

    // Set up daily consolidation (run at midnight)
    const now = new Date();
    const msUntilMidnight = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1).getTime() - now.getTime();
    
    setTimeout(() => {
      consolidateYesterday(config);
      
      // Then run daily consolidation every 24 hours
      consolidationInterval = setInterval(() => {
        consolidateYesterday(config);
      }, 24 * 60 * 60 * 1000);
    }, msUntilMidnight);

    app.debug('Zennora SignalK to Parquet plugin started');
  };

  plugin.stop = function() {
    app.debug('Stopping Zennora SignalK to Parquet plugin');
    
    // Clear intervals
    if (saveInterval) {
      clearInterval(saveInterval);
    }
    if (consolidationInterval) {
      clearInterval(consolidationInterval);
    }

    // Save any remaining buffered data
    saveAllBuffers();

    // Unsubscribe from all paths
    unsubscribes.forEach(unsubscribe => {
      if (typeof unsubscribe === 'function') {
        unsubscribe();
      }
    });
    unsubscribes = [];
    
    // Clear data structures
    dataBuffers.clear();
    activeRegimens.clear();
    subscribedPaths.clear();
  };

  // Subscribe to command paths that control regimens using proper subscription manager
  function subscribeToCommandPaths(config) {
    const commandPaths = config.paths.filter(pathConfig => 
      pathConfig.path.startsWith('commands.') && pathConfig.enabled
    );

    if (commandPaths.length === 0) return;

    const commandSubscription = {
      context: 'vessels.self',
      subscribe: commandPaths.map(pathConfig => ({
        path: pathConfig.path,
        period: 1000  // Check commands every second
      }))
    };

    app.debug(`Subscribing to ${commandPaths.length} command paths via subscription manager`);

    app.subscriptionmanager.subscribe(
      commandSubscription,
      unsubscribes,
      (subscriptionError) => {
        app.debug('Command subscription error:', subscriptionError);
      },
      (delta) => {
        // Process each update in the delta
        if (delta.updates) {
          delta.updates.forEach((update) => {
            if (update.values) {
              update.values.forEach((valueUpdate) => {
                const pathConfig = commandPaths.find(p => p.path === valueUpdate.path);
                if (pathConfig) {
                  handleCommandMessage(valueUpdate, pathConfig, config, update);
                }
              });
            }
          });
        }
      }
    );

    commandPaths.forEach(pathConfig => {
      subscribedPaths.add(pathConfig.path);
    });
  }

  // Handle command messages (regimen control) - now receives complete delta structure
  function handleCommandMessage(valueUpdate, pathConfig, config, update) {
    try {
      app.debug(`ðŸ“¦ Received command update for ${pathConfig.path}:`, JSON.stringify(valueUpdate, null, 2));
      
      if (valueUpdate.value !== undefined) {
        const commandName = extractCommandName(pathConfig.path);
        const isActive = Boolean(valueUpdate.value);
        
        app.debug(`Command ${commandName}: ${isActive ? 'ACTIVE' : 'INACTIVE'}`);
        
        if (isActive) {
          activeRegimens.add(commandName);
        } else {
          activeRegimens.delete(commandName);
        }
        
        // Debug active regimens state
        app.debug(`ðŸŽ¯ Active regimens: [${Array.from(activeRegimens).join(', ')}]`);
        
        // Update data subscriptions based on new regimen state
        updateDataSubscriptions(config);
        
        // Buffer this command change with complete metadata
        bufferData(pathConfig.path, {
          received_timestamp: new Date().toISOString(),
          signalk_timestamp: update.timestamp,
          context: 'vessels.self',
          path: valueUpdate.path,
          value: valueUpdate.value,
          source: update.source ? JSON.stringify(update.source) : null,
          source_label: update.$source || (update.source ? update.source.label : null),
          source_type: update.source ? update.source.type : null,
          source_pgn: update.source ? update.source.pgn : null,
          source_src: update.source ? update.source.src : null,
          meta: valueUpdate.meta ? JSON.stringify(valueUpdate.meta) : null
        }, config);
      }
    } catch (error) {
      app.debug('Error handling command message:', error);
    }
  }

  // Update data path subscriptions based on active regimens
  function updateDataSubscriptions(config) {
    const dataPaths = config.paths.filter(pathConfig => 
      !pathConfig.path.startsWith('commands.')
    );

    const shouldSubscribePaths = dataPaths.filter(pathConfig => shouldSubscribeToPath(pathConfig));
    
    if (shouldSubscribePaths.length === 0) {
      app.debug('No data paths need subscription currently');
      return;
    }

    // Create subscription for all needed data paths
    const dataSubscription = {
      context: 'vessels.self',
      subscribe: shouldSubscribePaths.map(pathConfig => ({
        path: pathConfig.path,
        period: 1000  // Get updates every second max
      }))
    };

    app.debug(`Subscribing to ${shouldSubscribePaths.length} data paths via subscription manager`);

    app.subscriptionmanager.subscribe(
      dataSubscription,
      unsubscribes,
      (subscriptionError) => {
        app.debug('Data subscription error:', subscriptionError);
      },
      (delta) => {
        // Process each update in the delta
        if (delta.updates) {
          delta.updates.forEach((update) => {
            if (update.values) {
              update.values.forEach((valueUpdate) => {
                const pathConfig = shouldSubscribePaths.find(p => p.path === valueUpdate.path);
                if (pathConfig) {
                  handleDataMessage(valueUpdate, pathConfig, config, update);
                }
              });
            }
          });
        }
      }
    );

    shouldSubscribePaths.forEach(pathConfig => {
      subscribedPaths.add(pathConfig.path);
    });
  }

  // Determine if we should subscribe to a path based on regimens
  function shouldSubscribeToPath(pathConfig) {
    // Always subscribe if explicitly enabled
    if (pathConfig.enabled) {
      app.debug(`âœ… Path ${pathConfig.path} enabled (always on)`);
      return true;
    }

    // Check if any required regimens are active
    if (pathConfig.regimen) {
      const requiredRegimens = pathConfig.regimen.split(',').map(r => r.trim());
      const hasActiveRegimen = requiredRegimens.some(regimen => activeRegimens.has(regimen));
      app.debug(`ðŸ” Path ${pathConfig.path} requires regimens [${requiredRegimens.join(', ')}], active: [${Array.from(activeRegimens).join(', ')}] â†’ ${hasActiveRegimen ? 'SUBSCRIBE' : 'SKIP'}`);
      return hasActiveRegimen;
    }

    app.debug(`âŒ Path ${pathConfig.path} has no regimen control and not enabled`);
    return false;
  }

  // Handle data messages from SignalK - now receives complete delta structure
  function handleDataMessage(valueUpdate, pathConfig, config, update) {
    try {
      // Check if we should still process this path
      if (!shouldSubscribeToPath(pathConfig)) {
        return;
      }

      const record = {
        received_timestamp: new Date().toISOString(),
        signalk_timestamp: update.timestamp,
        context: 'vessels.self',
        path: valueUpdate.path,
        value: null,
        value_json: null,
        source: update.source ? JSON.stringify(update.source) : null,
        source_label: update.$source || (update.source ? update.source.label : null),
        source_type: update.source ? update.source.type : null,
        source_pgn: update.source ? update.source.pgn : null,
        source_src: update.source ? update.source.src : null,
        meta: valueUpdate.meta ? JSON.stringify(valueUpdate.meta) : null
      };

      // Handle different value types (matching Python logic)
      if (typeof valueUpdate.value === 'object' && valueUpdate.value !== null) {
        record.value_json = JSON.stringify(valueUpdate.value);
        
        // Flatten object properties for easier querying
        for (const [key, val] of Object.entries(valueUpdate.value)) {
          if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {
            record[`value_${key}`] = val;
          }
        }
      } else {
        record.value = valueUpdate.value;
      }

      bufferData(pathConfig.path, record, config);

    } catch (error) {
      app.debug('Error handling data message:', error);
    }
  }

  // Buffer data and trigger save if buffer is full
  function bufferData(signalkPath, record, config) {
    if (!dataBuffers.has(signalkPath)) {
      dataBuffers.set(signalkPath, []);
      app.debug(`ðŸ†• Created new buffer for path: ${signalkPath}`);
    }
    
    const buffer = dataBuffers.get(signalkPath);
    buffer.push(record);
    
    // Debug every 100 records to show buffer growth
    if (buffer.length % 100 === 0) {
      app.debug(`ðŸ“Š Buffer for ${signalkPath}: ${buffer.length}/${config.bufferSize} records`);
    }
    
    if (buffer.length >= config.bufferSize) {
      app.debug(`ðŸš€ Buffer full for ${signalkPath} (${buffer.length} records) - triggering save`);
      saveBufferToParquet(signalkPath, buffer, config);
      dataBuffers.set(signalkPath, []); // Clear buffer
      app.debug(`ðŸ§¹ Buffer cleared for ${signalkPath}`);
    }
  }

  // Save all buffers (called periodically and on shutdown)
  function saveAllBuffers(config) {
    const totalBuffers = dataBuffers.size;
    let buffersWithData = 0;
    let totalRecords = 0;
    
    dataBuffers.forEach((buffer, signalkPath) => {
      if (buffer.length > 0) {
        buffersWithData++;
        totalRecords += buffer.length;
        app.debug(`â° Periodic save for ${signalkPath}: ${buffer.length} records`);
        saveBufferToParquet(signalkPath, buffer, config);
        dataBuffers.set(signalkPath, []); // Clear buffer
      }
    });
    
    if (buffersWithData > 0) {
      app.debug(`ðŸ’¾ Periodic save completed: ${buffersWithData}/${totalBuffers} paths, ${totalRecords} total records`);
    }
  }

  // Save buffer to Parquet file
  async function saveBufferToParquet(signalkPath, buffer, config) {
    try {
      // Create path-based directory structure (vessels/self/navigation/position)
      const dirPath = path.join(config.outputDirectory, 'vessels', 'self', signalkPath.replace(/\./g, '/'));
      await fs.ensureDir(dirPath);
      
      // Generate filename with timestamp
      const timestamp = new Date().toISOString().replace(/[:.]/g, '').slice(0, 15);
      const fileExt = config.fileFormat === 'csv' ? 'csv' : (config.fileFormat === 'parquet' ? 'parquet' : 'json');
      const filename = `${config.filenamePrefix}_${timestamp}.${fileExt}`;
      const filepath = path.join(dirPath, filename);
      
      // Use ParquetWriter to save in the configured format
      const savedPath = await parquetWriter.writeRecords(filepath, buffer);
      
      app.debug(`ðŸ’¾ Saved ${buffer.length} records to ${path.basename(savedPath)} for path: ${signalkPath}`);
      
    } catch (error) {
      app.debug(`âŒ Error saving buffer for ${signalkPath}:`, error);
    }
  }

  // Daily consolidation function
  async function consolidateYesterday(config) {
    try {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      
      const consolidatedCount = await parquetWriter.consolidateDaily(
        config.outputDirectory, 
        yesterday, 
        config.filenamePrefix
      );
      
      if (consolidatedCount > 0) {
        app.debug(`Consolidated ${consolidatedCount} topic directories for ${yesterday.toISOString().split('T')[0]}`);
      }
    } catch (error) {
      app.debug('Error during daily consolidation:', error);
    }
  }

  // Helper functions
  function extractCommandName(signalkPath) {
    // Extract command name from "commands.captureWeather"
    const parts = signalkPath.split('.');
    return parts[parts.length - 1];
  }


  function getDefaultPaths() {
    // Return default SignalK paths for initial testing
    return [
      {
        name: "Capture Weather Command",
        path: "commands.captureWeather",
        description: "Boolean command to enable weather data capture",
        enabled: true
      },
      {
        name: "Capture Passage Command", 
        path: "commands.capturePassage",
        description: "Boolean command to enable passage data capture",
        enabled: true
      },
      {
        name: "Navigation Position",
        path: "navigation.position",
        description: "GPS position data with latitude, longitude, altitude",
        enabled: false,
        regimen: "capturePassage, captureWeather"
      },
      {
        name: "Wind Speed Apparent",
        path: "environment.wind.speedApparent", 
        description: "Apparent wind speed",
        enabled: false,
        regimen: "captureWeather"
      },
      {
        name: "Wind Direction Apparent",
        path: "environment.wind.angleApparent",
        description: "Apparent wind direction", 
        enabled: false,
        regimen: "captureWeather"
      },
      {
        name: "Design Beam",
        path: "design.beam",
        description: "Vessel beam measurement",
        enabled: false,
        regimen: ""
      }
    ];
  }

  plugin.schema = {
    type: 'object',
    properties: {
      bufferSize: {
        type: 'number',
        title: 'Buffer Size',
        description: 'Number of records to buffer before writing to file',
        default: 1000,
        minimum: 10,
        maximum: 10000
      },
      saveIntervalSeconds: {
        type: 'number', 
        title: 'Save Interval (seconds)',
        description: 'How often to save buffered data to files',
        default: 30,
        minimum: 5,
        maximum: 300
      },
      outputDirectory: {
        type: 'string',
        title: 'Output Directory',
        description: 'Directory to save data files (defaults to application_data/{vessel}/zennora-signalk-parquet)',
        default: ''
      },
      filenamePrefix: {
        type: 'string',
        title: 'Filename Prefix', 
        description: 'Prefix for generated filenames',
        default: 'signalk_data'
      },
      fileFormat: {
        type: 'string',
        title: 'File Format',
        description: 'Format for saved data files',
        enum: ['json', 'csv', 'parquet'],
        default: 'parquet'
      },
      retentionDays: {
        type: 'number',
        title: 'Retention Days',
        description: 'Days to keep processed files',
        default: 7,
        minimum: 1,
        maximum: 365
      },
      paths: {
        type: 'array',
        title: 'SignalK Paths',
        description: 'Configure which SignalK paths to collect',
        items: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              title: 'Path Name'
            },
            path: {
              type: 'string', 
              title: 'SignalK Path',
              description: 'Example: navigation.position, design.beam, commands.captureWeather'
            },
            description: {
              type: 'string',
              title: 'Description'
            },
            enabled: {
              type: 'boolean',
              title: 'Always Enabled',
              default: false
            },
            regimen: {
              type: 'string',
              title: 'Regimen Control',
              description: 'Comma-separated list of regimens that enable this path'
            }
          }
        }
      }
    }
  };

  return plugin;
};